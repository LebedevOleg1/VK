# Task Scheduler

Простой планировщик задач на C++, позволяющий выполнять отложенные задачи не раньше заданного времени. Реализация использует стандартную библиотеку (`<thread>`, `<mutex>`, `<condition_variable>`, `<queue>`, `<functional>` и др.).

## Возможности

- Добавление задач с указанием времени начала исполнения (`std::time_t`).
- Очередь задач с приоритетом по времени исполнения.
- Фоновый поток, обрабатывающий задачи в нужное время.
- Безопасность при доступе из нескольких потоков (используются мьютексы и условные переменные).

## Пример использования

```cpp
Scheduler scheduler;

scheduler.Add([]() {
    std::cout << "Task 1 executed at " << std::time(nullptr) << std::endl;
}, std::time(nullptr) + 3);

scheduler.Add([]() {
    std::cout << "Task 2 executed at " << std::time(nullptr) << std::endl;
}, std::time(nullptr) + 1);

scheduler.Add([]() {
    std::cout << "Task 3 executed at " << std::time(nullptr) << std::endl;
}, std::time(nullptr) + 5);

// Даем задачам выполниться
std::this_thread::sleep_for(std::chrono::seconds(7));
```

## ВЫВОД
```bash
Task 2 executed at 1749585723
Task 1 executed at 1749585725
Task 3 executed at 1749585727
```


## Как работает

Класс `Scheduler` реализует простой однопоточный планировщик задач. Его задача — запускать переданные функции не раньше заданного времени. Ниже описаны основные этапы его работы:

### 1. Добавление задачи

Когда вызывается метод `Add`, задача вместе с временем запуска упаковывается в структуру и добавляется в приоритетную очередь. Эта очередь отсортирована так, чтобы задача с ближайшим временем исполнения находилась первой. Если новая задача должна выполниться раньше всех других — фоновый поток будет оповещён, чтобы пересчитать время ожидания.

### 2. Очередь задач

Задачи хранятся в приоритетной очереди, отсортированной по времени запуска. Это позволяет эффективно извлекать следующую задачу к выполнению. Очередь автоматически упорядочивает задачи от самой ранней к самой поздней.

### 3. Фоновый поток

При создании объекта планировщика запускается отдельный поток. Он постоянно ждёт ближайшую задачу. Поток "спит" до нужного времени с помощью механизма условных переменных и функции ожидания до определённого момента. Если в это время добавляется новая, более срочная задача — поток немедленно пробуждается и пересчитывает время ожидания.

### 4. Исполнение задач

Когда наступает момент выполнения, поток извлекает задачу из очереди и запускает её. При этом блокировка (мьютекс) временно отпускается, чтобы другие потоки могли добавлять задачи параллельно. Выполнение защищено от сбоев: если задача выбрасывает исключение, оно подавляется, чтобы не прервать работу всего планировщика.

### 5. Завершение работы

Когда объект `Scheduler` уничтожается или вызывается метод остановки, устанавливается специальный флаг, указывающий, что нужно завершить выполнение. Поток пробуждается, проверяет флаг и корректно завершается. Это гарантирует, что ни одна задача не останется "висеть", а ресурсы будут освобождены.


## Сборка

```bash
g++ VK.cpp -o vk
```

## Запуск

```bash
./vk
```